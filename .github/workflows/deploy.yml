name: Deploy Static Websites

on:
  push:
    branches:
      - main
      - production
  pull_request:
    branches:
      - main
      - production
  workflow_dispatch:

env:
  TF_VERSION: '1.6.0'
  AWS_REGION: 'us-east-1'
  TF_STATE_BUCKET: 'ahara-static-websites-tf-state'
  TF_STATE_DYNAMODB_TABLE: 'ahara-static-websites-tf-lock'

jobs:
  setup-backend:
    name: Setup Terraform Backend
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v5
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Create S3 bucket for Terraform state
        run: |
          # Check if bucket exists
          if aws s3 ls "s3://${{ env.TF_STATE_BUCKET }}" 2>&1 | grep -q 'NoSuchBucket'; then
            echo "üì¶ Creating S3 bucket for Terraform state..."
            aws s3api create-bucket \
              --bucket ${{ env.TF_STATE_BUCKET }} \
              --region ${{ env.AWS_REGION }}
          
            # Enable versioning
            aws s3api put-bucket-versioning \
              --bucket ${{ env.TF_STATE_BUCKET }} \
              --versioning-configuration Status=Enabled
          
            # Enable encryption
            aws s3api put-bucket-encryption \
              --bucket ${{ env.TF_STATE_BUCKET }} \
              --server-side-encryption-configuration '{
                "Rules": [{
                  "ApplyServerSideEncryptionByDefault": {
                    "SSEAlgorithm": "AES256"
                  }
                }]
              }'
          
            # Block public access
            aws s3api put-public-access-block \
              --bucket ${{ env.TF_STATE_BUCKET }} \
              --public-access-block-configuration \
                "BlockPublicAcls=true,IgnorePublicAcls=true,BlockPublicPolicy=true,RestrictPublicBuckets=true"
          
            echo "‚úÖ S3 bucket created and configured"
          else
            echo "‚úÖ S3 bucket already exists"
          fi

      - name: Create DynamoDB table for state locking
        run: |
          # Check if table exists
          if ! aws dynamodb describe-table --table-name ${{ env.TF_STATE_DYNAMODB_TABLE }} 2>&1 | grep -q 'TableName'; then
            echo "üîê Creating DynamoDB table for state locking..."
            aws dynamodb create-table \
              --table-name ${{ env.TF_STATE_DYNAMODB_TABLE }} \
              --attribute-definitions AttributeName=LockID,AttributeType=S \
              --key-schema AttributeName=LockID,KeyType=HASH \
              --billing-mode PAY_PER_REQUEST \
              --region ${{ env.AWS_REGION }}
          
            # Wait for table to be active
            aws dynamodb wait table-exists \
              --table-name ${{ env.TF_STATE_DYNAMODB_TABLE }}
          
            echo "‚úÖ DynamoDB table created"
          else
            echo "‚úÖ DynamoDB table already exists"
          fi

  terraform-plan:
    name: Terraform Plan
    needs: setup-backend
    runs-on: ubuntu-latest
    outputs:
      tfplanExitCode: ${{ steps.tf-plan.outputs.exitcode }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v5
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Terraform Init
        run: |
          cd infrastructure/terraform
          terraform init \
            -backend-config="bucket=${{ env.TF_STATE_BUCKET }}" \
            -backend-config="region=${{ env.AWS_REGION }}" \
            -backend-config="dynamodb_table=${{ env.TF_STATE_DYNAMODB_TABLE }}" \
            -backend-config="encrypt=true"

      - name: Terraform Format Check
        run: |
          cd infrastructure/terraform
          terraform fmt -check -recursive
        continue-on-error: true

      - name: Terraform Validate
        run: |
          cd infrastructure/terraform
          terraform validate

      - name: Terraform Plan
        id: tf-plan
        run: |
          cd infrastructure/terraform
          export exitcode=0
          terraform plan -detailed-exitcode -no-color -out=tfplan || export exitcode=$?
          
          echo "exitcode=$exitcode" >> $GITHUB_OUTPUT
          
          if [ $exitcode -eq 1 ]; then
            echo "Terraform Plan Failed!"
            exit 1
          else 
            exit 0
          fi

      - name: Publish Terraform Plan
        uses: actions/github-script@v8
        if: github.event_name == 'pull_request'
        env:
          PLAN: "terraform\n${{ steps.tf-plan.outputs.stdout }}"
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const output = `#### Terraform Format and Style üñå\`${{ steps.tf-fmt.outcome }}\`
            #### Terraform Initialization ‚öôÔ∏è\`${{ steps.tf-init.outcome }}\`
            #### Terraform Validation ü§ñ\`${{ steps.tf-validate.outcome }}\`
            <details><summary>Validation Output</summary>

            \`\`\`\n
            ${{ steps.tf-validate.outputs.stdout }}
            \`\`\`

            </details>

            #### Terraform Plan üìñ\`${{ steps.tf-plan.outcome }}\`
            
            <details><summary>Show Plan</summary>
            
            \`\`\`\n
            ${process.env.PLAN}
            \`\`\`
            
            </details>
            
            *Pusher: @${{ github.actor }}, Action: \`${{ github.event_name }}\`, Workflow: \`${{ github.workflow }}\`*`;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: output
            })

      - name: Upload Terraform Plan
        uses: actions/upload-artifact@v4
        with:
          name: tfplan
          path: infrastructure/terraform/tfplan
          retention-days: 5

  terraform-apply:
    name: Terraform Apply
    needs: [setup-backend, terraform-plan]
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/production'
    runs-on: ubuntu-latest
    environment: production
    outputs:
      sites_json: ${{ steps.get-outputs.outputs.sites_json }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: false

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v5
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Download Terraform Plan
        uses: actions/download-artifact@v5
        with:
          name: tfplan
          path: infrastructure/terraform

      - name: Terraform Init
        run: |
          cd infrastructure/terraform
          terraform init \
            -backend-config="bucket=${{ env.TF_STATE_BUCKET }}" \
            -backend-config="region=${{ env.AWS_REGION }}" \
            -backend-config="dynamodb_table=${{ env.TF_STATE_DYNAMODB_TABLE }}" \
            -backend-config="encrypt=true"

      - name: Terraform Apply
        run: |
          cd infrastructure/terraform
          
          terraform apply -auto-approve tfplan
          
          # Get all sites information from Terraform outputs
          SITES_JSON=$(terraform output -json all_sites)
          echo "sites_json<<EOF" >> $GITHUB_OUTPUT
          echo "$SITES_JSON" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          echo "üìä Site configurations:"
          echo "$SITES_JSON" | jq '.'
          
          terraform output -json all_sites > sites-config.json
          cat sites-config.json

      - name: Get Terraform Outputs
        id: get-outputs
        run: |
          cd infrastructure/terraform
          terraform state pull > /dev/null
    
          # Small delay to ensure S3 consistency
          sleep 2
          
          # Get all sites information from Terraform outputs
          SITES_JSON=$(terraform output -json all_sites)
          echo "sites_json<<EOF" >> $GITHUB_OUTPUT
          echo "$SITES_JSON" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          echo "üìä Site configurations:"
          echo "$SITES_JSON" | jq '.'

      - name: Save outputs to artifact
        run: |
          cd infrastructure/terraform
          terraform output -json all_sites > sites-config.json
          cat sites-config.json

      - name: Upload sites configuration
        uses: actions/upload-artifact@v4
        with:
          name: sites-config
          path: infrastructure/terraform/sites-config.json
          retention-days: 5

  deploy-sites:
    name: Deploy Sites and Invalidate Cache
    needs: [setup-backend, terraform-apply]
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v5
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Download sites configuration
        uses: actions/download-artifact@v5
        with:
          name: sites-config

      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Deploy all sites
        run: |
          # Read the sites configuration
          SITES_JSON=$(cat sites-config.json)
          
          # Get list of site names
          SITE_NAMES=$(echo "$SITES_JSON" | jq -r 'keys[]')
          
          echo "üöÄ Deploying sites..."
          
          for site in $SITE_NAMES; do
            echo "================================================"
            echo "üì¶ Processing site: $site"
            echo "================================================"
          
            # Extract site details
            S3_BUCKET=$(echo "$SITES_JSON" | jq -r ".[\"$site\"].s3_bucket")
            CLOUDFRONT_ID=$(echo "$SITES_JSON" | jq -r ".[\"$site\"].cloudfront_id")
            LOCAL_PATH=$(echo "$SITES_JSON" | jq -r ".[\"$site\"].local_path")
            HOSTNAME=$(echo "$SITES_JSON" | jq -r ".[\"$site\"].hostname")
          
            echo "  S3 Bucket: $S3_BUCKET"
            echo "  CloudFront ID: $CLOUDFRONT_ID"
            echo "  Local Path: $LOCAL_PATH"
            echo "  Hostname: $HOSTNAME"
          
            # Check if local path exists
            if [ ! -d "$LOCAL_PATH" ]; then
              echo "  ‚ö†Ô∏è  Warning: Local path $LOCAL_PATH does not exist, skipping..."
              continue
            fi
          
            # Sync files to S3
            echo "  üì§ Syncing files to S3..."
            aws s3 sync "$LOCAL_PATH/" "s3://$S3_BUCKET/" \
              --cache-control "public, max-age=3600" \
              --exclude "*.map" \
              --exclude ".git/*" \
              --exclude ".github/*"
          
            echo "  ‚úÖ Files synced to S3"
          
            # Create CloudFront invalidation
            echo "  üîÑ Creating CloudFront invalidation..."
            INVALIDATION_ID=$(aws cloudfront create-invalidation \
              --distribution-id "$CLOUDFRONT_ID" \
              --paths "/*" \
              --query 'Invalidation.Id' \
              --output text)
          
            echo "  ‚úÖ CloudFront invalidation created: $INVALIDATION_ID"
            echo "  üåê Site URL: https://$HOSTNAME"
            echo ""
          done
          
          echo "================================================"
          echo "üéâ All sites deployed successfully!"
          echo "================================================"

      - name: Wait for invalidations
        run: |
          SITES_JSON=$(cat sites-config.json)
          SITE_NAMES=$(echo "$SITES_JSON" | jq -r 'keys[]')
          
          echo "‚è≥ Waiting for CloudFront invalidations to complete..."
          
          for site in $SITE_NAMES; do
            CLOUDFRONT_ID=$(echo "$SITES_JSON" | jq -r ".[\"$site\"].cloudfront_id")
            HOSTNAME=$(echo "$SITES_JSON" | jq -r ".[\"$site\"].hostname")
          
            echo "  ‚åõ Waiting for $HOSTNAME (Distribution: $CLOUDFRONT_ID)..."
          
            # Get the most recent invalidation ID
            INVALIDATION_ID=$(aws cloudfront list-invalidations \
              --distribution-id "$CLOUDFRONT_ID" \
              --query 'InvalidationList.Items[0].Id' \
              --output text)
          
            if [ "$INVALIDATION_ID" != "None" ] && [ -n "$INVALIDATION_ID" ]; then
              aws cloudfront wait invalidation-completed \
                --distribution-id "$CLOUDFRONT_ID" \
                --id "$INVALIDATION_ID"
          
              echo "  ‚úÖ $HOSTNAME invalidation completed"
            fi
          done
          
          echo "üéâ All invalidations completed!"

  notify:
    name: Notify Deployment Status
    needs: [terraform-apply, deploy-sites]
    if: always()
    runs-on: ubuntu-latest
    
    steps:
      - name: Download sites configuration
        if: needs.terraform-apply.result == 'success'
        uses: actions/download-artifact@v5
        with:
          name: sites-config
        continue-on-error: true

      - name: Deployment Success Summary
        if: needs.deploy-sites.result == 'success'
        run: |
          echo "üéâ Deployment completed successfully!"
          echo ""
          echo "Deployed sites:"
          
          if [ -f sites-config.json ]; then
            cat sites-config.json | jq -r 'to_entries[] | "  ‚Ä¢ \(.value.hostname) - \(.value.url)"'
          fi

      - name: Deployment Failed
        if: needs.deploy-sites.result == 'failure' || needs.terraform-apply.result == 'failure'
        run: |
          echo "‚ùå Deployment failed!"
          exit 1