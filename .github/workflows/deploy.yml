name: Deploy Static Websites

on:
  push:
    branches:
      - main
    paths:
      - 'infrastructure/**'
  pull_request:
    branches:
      - main
    types: [opened, synchronize, reopened, ready_for_review]
  workflow_dispatch:

concurrency:
  group: production-deploy
  cancel-in-progress: false

permissions:
  id-token: write   # required for OIDC
  contents: read

env:
  TF_VERSION: '1.6.0'
  AWS_REGION: 'us-east-1'

jobs:
  terraform:
    name: Terraform
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Configure AWS credentials via OIDC
        uses: aws-actions/configure-aws-credentials@v5
        with:
          role-to-assume: ${{ secrets.OIDC_ROLE }}
          role-session-name: GitHubActions-${{ github.run_id }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Terraform Init
        env:
          TF_CLI_ARGS: -no-color
        run: |
          cd infrastructure/terraform
          terraform init \
            -backend-config bucket=${{ secrets.STATE_BUCKET }} \
            -backend-config region=${{ env.AWS_REGION }}

      - name: Terraform Format Check
        env:
          TF_CLI_ARGS: -no-color
        run: |
          cd infrastructure/terraform
          terraform fmt -check -recursive
        continue-on-error: true

      - name: Terraform Validate
        env:
          TF_CLI_ARGS: -no-color
        run: |
          cd infrastructure/terraform
          terraform validate

      - name: Terraform Plan
        id: tf-plan
        env:
          TF_CLI_ARGS: -no-color
          TF_VAR_prefix: ${{ secrets.PREFIX }}
          TF_VAR_permissions_boundary_arn: ${{ secrets.PB_ARN }}
        run: |
          cd infrastructure/terraform
          terraform plan -input=false -out=tfplan

      - name: Terraform Apply
        if: github.ref == 'refs/heads/main'
        env:
          TF_CLI_ARGS: -no-color
        run: |
          cd infrastructure/terraform
          terraform apply -auto-approve tfplan
          
          # Get all sites information from Terraform outputs
          terraform output -json all_sites > sites-config.json
          cat sites-config.json

      - name: Deploy all sites
        if: github.ref == 'refs/heads/main'
        run: |
          # Read the sites configuration
          SITES_JSON=$(cat sites-config.json)
          
          # Get list of site names
          SITE_NAMES=$(echo "$SITES_JSON" | jq -r 'keys[]')
          
          echo "üöÄ Deploying sites..."
          
          for site in $SITE_NAMES; do
            echo "================================================"
            echo "üì¶ Processing site: $site"
            echo "================================================"
          
            # Extract site details
            S3_BUCKET=$(echo "$SITES_JSON" | jq -r ".[\"$site\"].s3_bucket")
            CLOUDFRONT_ID=$(echo "$SITES_JSON" | jq -r ".[\"$site\"].cloudfront_id")
            LOCAL_PATH=$(echo "$SITES_JSON" | jq -r ".[\"$site\"].local_path")
            HOSTNAME=$(echo "$SITES_JSON" | jq -r ".[\"$site\"].hostname")
          
            echo "  S3 Bucket: $S3_BUCKET"
            echo "  CloudFront ID: $CLOUDFRONT_ID"
            echo "  Local Path: $LOCAL_PATH"
            echo "  Hostname: $HOSTNAME"
          
            # Check if local path exists
            if [ ! -d "$LOCAL_PATH" ]; then
              echo "  ‚ö†Ô∏è  Warning: Local path $LOCAL_PATH does not exist, skipping..."
              continue
            fi
          
            # Sync files to S3
            echo "  üì§ Syncing files to S3..."
            aws s3 sync "$LOCAL_PATH/" "s3://$S3_BUCKET/" \
              --cache-control "public, max-age=3600" \
              --exclude "*.map" \
              --exclude ".git/*" \
              --exclude ".github/*"
          
            echo "  ‚úÖ Files synced to S3"
          
            # Create CloudFront invalidation
            echo "  üîÑ Creating CloudFront invalidation..."
            INVALIDATION_ID=$(aws cloudfront create-invalidation \
              --distribution-id "$CLOUDFRONT_ID" \
              --paths "/*" \
              --query 'Invalidation.Id' \
              --output text)
          
            echo "  ‚úÖ CloudFront invalidation created: $INVALIDATION_ID"
            echo "  üåê Site URL: https://$HOSTNAME"
            echo ""
          done
          
          echo "================================================"
          echo "üéâ All sites deployed successfully!"
          echo "================================================"

      - name: Wait for invalidations
        if: github.ref == 'refs/heads/main'
        run: |
          SITES_JSON=$(cat sites-config.json)
          SITE_NAMES=$(echo "$SITES_JSON" | jq -r 'keys[]')
          
          echo "‚è≥ Waiting for CloudFront invalidations to complete..."
          
          for site in $SITE_NAMES; do
            CLOUDFRONT_ID=$(echo "$SITES_JSON" | jq -r ".[\"$site\"].cloudfront_id")
            HOSTNAME=$(echo "$SITES_JSON" | jq -r ".[\"$site\"].hostname")
          
            echo "  ‚åõ Waiting for $HOSTNAME (Distribution: $CLOUDFRONT_ID)..."
          
            # Get the most recent invalidation ID
            INVALIDATION_ID=$(aws cloudfront list-invalidations \
              --distribution-id "$CLOUDFRONT_ID" \
              --query 'InvalidationList.Items[0].Id' \
              --output text)
          
            if [ "$INVALIDATION_ID" != "None" ] && [ -n "$INVALIDATION_ID" ]; then
              aws cloudfront wait invalidation-completed \
                --distribution-id "$CLOUDFRONT_ID" \
                --id "$INVALIDATION_ID"
          
              echo "  ‚úÖ $HOSTNAME invalidation completed"
            fi
          done
          
          echo "üéâ All invalidations completed!"
